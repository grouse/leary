#include "rendering.h"

#include "gamestate.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb/stb_image.h"

#include <fstream>
#include <string>

void generateCube(GLuint* vertexArray, GLuint* vertexBuffer, GLuint* colourBuffer) {
	glGenVertexArrays(1, vertexArray);
	glBindVertexArray(*vertexArray);

	const GLfloat vertexBufferData[] = {
		-1.0f,-1.0f,-1.0f,
		-1.0f,-1.0f, 1.0f,
		-1.0f, 1.0f, 1.0f,
		 1.0f, 1.0f,-1.0f,
		-1.0f,-1.0f,-1.0f,
		-1.0f, 1.0f,-1.0f,
		 1.0f,-1.0f, 1.0f,
		-1.0f,-1.0f,-1.0f,
		 1.0f,-1.0f,-1.0f,
		 1.0f, 1.0f,-1.0f,
		 1.0f,-1.0f,-1.0f,
		-1.0f,-1.0f,-1.0f,
		-1.0f,-1.0f,-1.0f,
		-1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f,-1.0f,
		 1.0f,-1.0f, 1.0f,
		-1.0f,-1.0f, 1.0f,
		-1.0f,-1.0f,-1.0f,
		-1.0f, 1.0f, 1.0f,
		-1.0f,-1.0f, 1.0f,
		 1.0f,-1.0f, 1.0f,
		 1.0f, 1.0f, 1.0f,
		 1.0f,-1.0f,-1.0f,
		 1.0f, 1.0f,-1.0f,
		 1.0f,-1.0f,-1.0f,
		 1.0f, 1.0f, 1.0f,
		 1.0f,-1.0f, 1.0f,
		 1.0f, 1.0f, 1.0f,
		 1.0f, 1.0f,-1.0f,
		-1.0f, 1.0f,-1.0f,
		 1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f,-1.0f,
		-1.0f, 1.0f, 1.0f,
		 1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f, 1.0f,
		 1.0f,-1.0f, 1.0f
	};

	glGenBuffers(1, vertexBuffer);
	glBindBuffer(GL_ARRAY_BUFFER, *vertexBuffer);

	glBufferData(GL_ARRAY_BUFFER, sizeof(vertexBufferData), vertexBufferData, GL_STATIC_DRAW);
	
	static const GLfloat colourBufferData[] = {
		0.583f,  0.771f,  0.014f,
		0.609f,  0.115f,  0.436f,
		0.327f,  0.483f,  0.844f,
		0.822f,  0.569f,  0.201f,
		0.435f,  0.602f,  0.223f,
		0.310f,  0.747f,  0.185f,
		0.597f,  0.770f,  0.761f,
		0.559f,  0.436f,  0.730f,
		0.359f,  0.583f,  0.152f,
		0.483f,  0.596f,  0.789f,
		0.559f,  0.861f,  0.639f,
		0.195f,  0.548f,  0.859f,
		0.014f,  0.184f,  0.576f,
		0.771f,  0.328f,  0.970f,
		0.406f,  0.615f,  0.116f,
		0.676f,  0.977f,  0.133f,
		0.971f,  0.572f,  0.833f,
		0.140f,  0.616f,  0.489f,
		0.997f,  0.513f,  0.064f,
		0.945f,  0.719f,  0.592f,
		0.543f,  0.021f,  0.978f,
		0.279f,  0.317f,  0.505f,
		0.167f,  0.620f,  0.077f,
		0.347f,  0.857f,  0.137f,
		0.055f,  0.953f,  0.042f,
		0.714f,  0.505f,  0.345f,
		0.783f,  0.290f,  0.734f,
		0.722f,  0.645f,  0.174f,
		0.302f,  0.455f,  0.848f,
		0.225f,  0.587f,  0.040f,
		0.517f,  0.713f,  0.338f,
		0.053f,  0.959f,  0.120f,
		0.393f,  0.621f,  0.362f,
		0.673f,  0.211f,  0.457f,
		0.820f,  0.883f,  0.371f,
		0.982f,  0.099f,  0.879f
	};

	glGenBuffers(1, colourBuffer);
	glBindBuffer(GL_ARRAY_BUFFER, *colourBuffer);
	glBufferData(GL_ARRAY_BUFFER, sizeof(colourBufferData), colourBufferData, GL_STATIC_DRAW);
}

void generateTexturedCube(GLuint texture, GLuint* vertexArray, GLuint* vertexBuffer, GLuint* uvBuffer) {
	glGenVertexArrays(1, vertexArray);
	glBindVertexArray(*vertexArray);

	const GLfloat vertexBufferData[] = {
		-1.0f,-1.0f,-1.0f, 
		-1.0f,-1.0f, 1.0f,
		-1.0f, 1.0f, 1.0f,
		 1.0f, 1.0f,-1.0f,
		-1.0f,-1.0f,-1.0f,
		-1.0f, 1.0f,-1.0f,
		 1.0f,-1.0f, 1.0f,
		-1.0f,-1.0f,-1.0f,
		 1.0f,-1.0f,-1.0f,
		 1.0f, 1.0f,-1.0f,
		 1.0f,-1.0f,-1.0f,
		-1.0f,-1.0f,-1.0f,
		-1.0f,-1.0f,-1.0f,
		-1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f,-1.0f,
		 1.0f,-1.0f, 1.0f,
		-1.0f,-1.0f, 1.0f,
		-1.0f,-1.0f,-1.0f,
		-1.0f, 1.0f, 1.0f,
		-1.0f,-1.0f, 1.0f,
		 1.0f,-1.0f, 1.0f,
		 1.0f, 1.0f, 1.0f,
		 1.0f,-1.0f,-1.0f,
		 1.0f, 1.0f,-1.0f,
		 1.0f,-1.0f,-1.0f,
		 1.0f, 1.0f, 1.0f,
		 1.0f,-1.0f, 1.0f,
		 1.0f, 1.0f, 1.0f,
		 1.0f, 1.0f,-1.0f,
		-1.0f, 1.0f,-1.0f,
		 1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f,-1.0f,
		-1.0f, 1.0f, 1.0f,
		 1.0f, 1.0f, 1.0f,
		-1.0f, 1.0f, 1.0f,
		 1.0f,-1.0f, 1.0f
	};

	glGenBuffers(1, vertexBuffer);
	glBindBuffer(GL_ARRAY_BUFFER, *vertexBuffer);

	glBufferData(GL_ARRAY_BUFFER, sizeof(vertexBufferData), vertexBufferData, GL_STATIC_DRAW);

	static const GLfloat uvBufferData[] = {
		0.000059f, 1.0f-0.000004f, 
		0.000103f, 1.0f-0.336048f, 
		0.335973f, 1.0f-0.335903f, 
		1.000023f, 1.0f-0.000013f, 
		0.667979f, 1.0f-0.335851f, 
		0.999958f, 1.0f-0.336064f, 
		0.667979f, 1.0f-0.335851f, 
		0.336024f, 1.0f-0.671877f, 
		0.667969f, 1.0f-0.671889f, 
		1.000023f, 1.0f-0.000013f, 
		0.668104f, 1.0f-0.000013f, 
		0.667979f, 1.0f-0.335851f, 
		0.000059f, 1.0f-0.000004f, 
		0.335973f, 1.0f-0.335903f, 
		0.336098f, 1.0f-0.000071f, 
		0.667979f, 1.0f-0.335851f, 
		0.335973f, 1.0f-0.335903f, 
		0.336024f, 1.0f-0.671877f, 
		1.000004f, 1.0f-0.671847f, 
		0.999958f, 1.0f-0.336064f, 
		0.667979f, 1.0f-0.335851f, 
		0.668104f, 1.0f-0.000013f, 
		0.335973f, 1.0f-0.335903f, 
		0.667979f, 1.0f-0.335851f, 
		0.335973f, 1.0f-0.335903f, 
		0.668104f, 1.0f-0.000013f, 
		0.336098f, 1.0f-0.000071f, 
		0.000103f, 1.0f-0.336048f, 
		0.000004f, 1.0f-0.671870f, 
		0.336024f, 1.0f-0.671877f, 
		0.000103f, 1.0f-0.336048f, 
		0.336024f, 1.0f-0.671877f, 
		0.335973f, 1.0f-0.335903f, 
		0.667969f, 1.0f-0.671889f, 
		1.000004f, 1.0f-0.671847f, 
		0.667979f, 1.0f-0.335851f
	};


	glGenBuffers(1, uvBuffer);
	glBindBuffer(GL_ARRAY_BUFFER, *uvBuffer);
	glBufferData(GL_ARRAY_BUFFER, sizeof(uvBufferData), uvBufferData, GL_STATIC_DRAW);

}

void generateTriangle(GLuint* vertexArray, GLuint* vertexBuffer) {
	glGenVertexArrays(1, vertexArray);
	glBindVertexArray(*vertexArray);

	const GLfloat vertexBufferData[] = {
		-1.0f, -1.0f, 0.0f,
		 1.0f, -1.0f, 0.0f,
		 0.0f,  1.0f, 0.0f
	};

	glGenBuffers(1, vertexBuffer);
	glBindBuffer(GL_ARRAY_BUFFER, *vertexBuffer);

	glBufferData(GL_ARRAY_BUFFER, sizeof(vertexBufferData), vertexBufferData, GL_STATIC_DRAW);
}

GLuint loadShader(GLenum type, const char* file) {
	GLuint shader = glCreateShader(type);

	std::string shaderSource;
	std::ifstream shaderStream(file, std::ios::in);
	if (shaderStream.is_open()) {
		std::string line = "";
		while (std::getline(shaderStream, line))
			shaderSource += "\n" + line;

		shaderStream.close();
	}

	char const* shaderSourcePtr = shaderSource.c_str();
	glShaderSource(shader, 1, &shaderSourcePtr, NULL);
	glCompileShader(shader);

	GLint result = GL_FALSE;
	int infoLogLength;
	
	glGetShaderiv(shader, GL_COMPILE_STATUS, &result);
	glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLogLength);

	char* infoLog = new char[infoLogLength];
	glGetShaderInfoLog(shader, infoLogLength, NULL, infoLog);
	
	if (result == GL_FALSE)
		DebugPrintf(EDebugType::FATAL, EDebugCode::OGL_SHADER_COMPILE, "Failed to compile shader %s: %s", file, infoLog); 
	else 
		DebugPrintf(EDebugType::MESSAGE, EDebugCode::OGL_SHADER_COMPILE, "Compiled shader %s: %s", file, infoLog);
	
	delete[] infoLog;

	return shader;
}

GLuint loadShaders(const char* vertexFile, const char* fragmentFile) {
	GLuint vertexShader = loadShader(GL_VERTEX_SHADER, vertexFile); 
	GLuint fragmentShader = loadShader(GL_FRAGMENT_SHADER, fragmentFile); 

	GLuint shaderProgram = glCreateProgram();
	glAttachShader(shaderProgram, vertexShader);
	glAttachShader(shaderProgram, fragmentShader);
	glLinkProgram(shaderProgram);

	GLint result;
	int infoLogLength;
	
	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &result);
	glGetProgramiv(shaderProgram, GL_INFO_LOG_LENGTH, &infoLogLength);

	char* infoLog = new char[infoLogLength];
	glGetProgramInfoLog(shaderProgram, infoLogLength, NULL, infoLog);
	
	if (result == GL_FALSE) 
		DebugPrintf(EDebugType::FATAL, EDebugCode::OGL_SHADER_LINK, "Failed to link program: %s", infoLog);
	else
		DebugPrintf(EDebugType::MESSAGE, EDebugCode::OGL_SHADER_LINK, "Linked shader program program: %s", infoLog);

	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);
	delete[] infoLog;

	return shaderProgram;
}

GLuint loadTexture(const char* file) {
	GLuint texture = 0;

	int width, height, components;
	unsigned char* pixels = stbi_load(file, &width, &height, &components, 0);

	glGenTextures(1, &texture);
	glBindTexture(GL_TEXTURE_2D, texture);

	if (components == 3)
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);
	else if (components == 4) 
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
	else {
		DebugPrintf(EDebugType::ERROR, EDebugCode::OGL_TEXTURE_UNSUPPORTED_COMPONENTS, 
				"Trying to load texture with unsupported number of components: %s. Expected 3 or 4 components but got: %d", 
				file, components);

		return 0;
	}


	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

	glGenerateMipmap(GL_TEXTURE_2D);

	stbi_image_free(pixels);

	return texture;
}

Rendering::Rendering() {}
Rendering::~Rendering() {
	glDeleteBuffers(1, &vbo);
	glDeleteBuffers(1, &cbo);
	glDeleteProgram(shaderProgram);
	glDeleteVertexArrays(1, &vao);
	glDeleteTextures(1, &samplerLocation);

	SDL_GL_DeleteContext(glcontext);
	SDL_DestroyWindow(window);
}


void Rendering::init(GameState* gs) {
	this->game = gs;

	// setup SDL with OpenGL context
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
	
	window = SDL_CreateWindow(
		game->settings.general.title.c_str(),
		SDL_WINDOWPOS_UNDEFINED,
		SDL_WINDOWPOS_UNDEFINED,
		game->settings.video.resolution_x, game->settings.video.resolution_y,
		SDL_WINDOW_OPENGL
	);

	if (window == NULL)
		DebugPrintf(EDebugType::FATAL, EDebugCode::SDL_INIT_WINDOW, "Failed to initialise SDL Window: %s", SDL_GetError());

	SDL_SetWindowGrab(window, SDL_TRUE);

	
	// OpenGL setup
	camera.aspect_ratio = (float) game->settings.video.resolution_x / (float) game->settings.video.resolution_y;

	glcontext = SDL_GL_CreateContext(window);
	
	glewExperimental = GL_TRUE;
	glewInit();
	
	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);


	// load data into GPU
	// @TODO: move hardcoded into file loaded with the aid of rendering API
	
	//generateCube(&vao, &vbo, &cbo);	
	
	texture = loadTexture("data/textures/uvtemplate.tga");
	generateTexturedCube(texture, &vao, &vbo, &cbo);

	
	
	// load and compile shaders
	// @TODO: move hardcoded into file loaded with the aid of rendering API
	shaderProgram = loadShaders("data/shaders/vertex.glsl", "data/shaders/fragment.glsl");
	MVPLocation = glGetUniformLocation(shaderProgram, "MVP");	// get location of the uniform "MVP" in the program
	samplerLocation = glGetUniformLocation(shaderProgram, "textureSampler");

}

void Rendering::render() {
	// Compute camera matrices
	camera.forward = glm::vec3(
		cos(camera.verticalAngle) * sin(camera.horizontalAngle),
		sin(camera.verticalAngle),
		cos(camera.verticalAngle) * cos(camera.horizontalAngle)
	);
	
	camera.right = glm::vec3(
		sin(camera.horizontalAngle - 3.14f/2.0f),
		0,
		cos(camera.horizontalAngle - 3.14f/2.0f)
	);
	
	camera.up = glm::cross(camera.right, camera.forward);

	camera.projection = glm::perspective(
		camera.FoV,
		camera.aspect_ratio, // aspect ratio
		0.1f,                // near clipping plane
		100.0f               // far clipping plane
	);
	
	camera.view = glm::lookAt(
		camera.position, 
		camera.position + camera.forward, 
		camera.up
	);

	MVP = camera.projection * camera.view * glm::mat4(1.0f);
	


	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glUseProgram(shaderProgram);

	// send transforms to shader
	glUniformMatrix4fv(MVPLocation, 1, GL_FALSE, &MVP[0][0]);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, texture);
	glUniform1i(samplerLocation, 0);


	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

	glEnableVertexAttribArray(1);
	glBindBuffer(GL_ARRAY_BUFFER, cbo);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);

	glDrawArrays(GL_TRIANGLES, 0, 12*3);
	glDisableVertexAttribArray(0);
	glDisableVertexAttribArray(1);

	SDL_GL_SwapWindow(window);

	glUseProgram(0);
}
